<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../css/style.css" />
  
</head>
<body>
	
<div class="container_top">
<div id="left_top"></div>
<div id="middle_top">


<img src="../img/linux/kernel_1.jpg" alt="tcp 建立过程"/>
	
<div class="mycontent"><ul>
<li> net.ipv4.tcp_syncookies = 1 </li>
<li> net.ipv4.tcp_max_syn_backlog = 8192 </li>
<li> net.ipv4.tcp_fin_timeout = 30 </li>
<li> net.ipv4.tcp_max_tw_buckets = 5000 </li>
<li> net.ipv4.tcp_keepalive_time = 300 </li>
<li> net.ipv4.tcp_keepalive_probes = 3 </li>
<li> net.ipv4.tcp_keepalive_time = 30 </li>
<li>&nbsp;</li>
<li>&nbsp;</li>
<li> net.ipv4.tcp_tw_reuse = 1 </li>
<li> net.ipv4.tcp_tw_recycle = 0 </li>
<li>&nbsp;</li>
<li> # vm.swappiness=0 </li>
<li> ## 内核倾向于保留directory和inode cache </li>
<li> vm.vfs_cache_pressure=30 </li>
<li> ## 禁止“沿途MTU发现” </li>
<li> net.ipv4.ip_no_pmtu_disc=1 </li>
<li>&nbsp;</li>
<li> net.ipv4.ip_local_port_range = 1024 65535 </li>
<li> # Increase number of incoming connections </li>
<li>&nbsp;</li>
<li> ## 定义了系统中每一个端口最大的监听队列的长度 </li>
<li> net.core.somaxconn = 4096 </li>
<li> # Increase number of incoming connections backlog </li>
<li>&nbsp;</li>
<li> ##每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目 </li>
<li> net.core.netdev_max_backlog = 4096 </li>
<li> # allow testing with buffers up to 64MB </li>
<li>&nbsp;</li>
<li> ##接收套接字缓冲区大小的最大值(以字节为单位) </li>
<li> net.core.rmem_max = 67108864 </li>
<li> ##发送套接字缓冲区大小的最大值(以字节为单位) </li>
<li> net.core.wmem_max = 67108864 </li>
<li> # increase Linux autotuning TCP buffer limit to 32MB </li>
<li> ## TCP接收缓冲区，3个字段分别是min，default，max。 </li>
<li> net.ipv4.tcp_rmem = 4096 87380 33554432 </li>
<li> ## TCP发送缓冲区 </li>
<li> net.ipv4.tcp_wmem = 4096 65536 33554432 </li>
<li> # recommended default congestion control is htcp </li>
<li> net.ipv4.tcp_congestion_control=htcp </li>
<li> # recommended for hosts with jumbo frames enabled </li>
<li> #net.ipv4.tcp_mtu_probing=1 </li>
<li> # recommended for CentOS7/Debian8 hosts </li>
<li> net.core.default_qdisc = fq </li>
<li>&nbsp;</li>
<li>&nbsp;</li>
<li> net.ipv4.tcp_syncookies = 1 </li>
<li> 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； </li>
<li> net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数(tcp_max_syn_backlog&gt;=somaxconn) </li>
<li> net.ipv4.tcp_fin_timeout = 30 </li>
<li> 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间 </li>
<li> net.ipv4.tcp_max_tw_buckets = 5000 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。 </li>
<li>&nbsp;</li>
<li> tcp_keepalive_time ：INTEGER </li>
<li> 默认值是7200(2小时) </li>
<li> 当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击? tcp_keepalive_time就是预防此情形的.) </li>
<li> tcp_keepalive_probes：INTEGER </li>
<li> 默认值是9 </li>
<li> TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适) </li>
<li> tcp_keepalive_intvl：INTEGER </li>
<li> 默认值为75 </li>
<li> 探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值) </li>
<li>&nbsp;</li>
<li>&nbsp;</li>
<li>&nbsp;</li>
<li> net.ipv4.tcp_tw_reuse=1 </li>
<li> #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助) </li>
<li> net.ipv4.tcp_tw_recycle = 0 </li>
<li> 如果服务器身处NAT环境，安全起见，通常要禁止tcp_tw_recycle，如果nat下，开启了tcp_tw_recycle，可能会导致部分用户无法连接服务器的情况：在nat模式下（服务器一般会用到dnat，用户一般会用到snat），nat设备（or服务器）会修改目的ip和源ip，以屏蔽内部信息。 </li>
<li>&nbsp;</li>
<li> sysctl net.ipv4.tcp_available_congestion_control </li>
<li> 如果没有下文提到的htcp,hybla算法，你可以尝试通过modprobe启用模块： </li>
<li> /sbin/modprobe tcp_htcp </li>
<li> /sbin/modprobe tcp_hybla </li>
<li>&nbsp;</li>
<li> tcp_mtu_probing (integer; default: 0; since Linux 2.6.17): </li>
<li> This parameter controls TCP Packetization-Layer Path MTU Discovery. The following values may be assigned to the file: </li>
<li> 0 Disabled </li>
<li> 1 Disabled by default, enabled when an ICMP black hole detected </li>
<li> 2 Always enabled, use initial MSS of tcp_base_mss. </li>
</ul></div>
	
	
	
</div>
</div>
</body>
</html>
